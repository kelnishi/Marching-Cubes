#pragma kernel March
#include "./Includes/MarchTables.compute"

static const int numThreads = 8;

struct Triangle {
    int vertexC;
    int vertexB;
    int vertexA;
};

struct Edge
{
    int id;
    //The interpolated point
    float3 p;
};

AppendStructuredBuffer<Edge> edges;
AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float4> points;

int numPointsPerAxis;
float isoLevel;

float3 interpolateVerts(float4 v1, float4 v2) {
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz-v1.xyz);
}

int indexFromId(int3 id)
{
    return id.z * numPointsPerAxis * numPointsPerAxis + id.y * numPointsPerAxis + id.x;
}

int indexFromCoord(int x, int y, int z) {
    return z * numPointsPerAxis * numPointsPerAxis + y * numPointsPerAxis + x;
}

int calculateEdgeIndex(int3 id, int edge)
{
    const int X = 0;
    const int Y = 2;
    const int Z = 1;
    switch (edge)
    {
        case 0: return 4*indexFromCoord(id.x  , id.y  , id.z  ) +X;     //X
        case 1: return 4*indexFromCoord(id.x+1, id.y  , id.z  ) +Z;     //+X Z
        case 2: return 4*indexFromCoord(id.x  , id.y  , id.z+1) +X; //+Z X
        case 3: return 4*indexFromCoord(id.x  , id.y  , id.z  ) +Z;       //Z
        case 4: return 4*indexFromCoord(id.x  , id.y+1, id.z  ) +X;     //+Y X
        case 5: return 4*indexFromCoord(id.x+1, id.y+1, id.z  ) +Z;   //+X+Y Z
        case 6: return 4*indexFromCoord(id.x  , id.y+1, id.z+1) +X; //+Z+Y X
        case 7: return 4*indexFromCoord(id.x  , id.y+1, id.z  ) +Z;     //+Y Z
        case 8: return 4*indexFromCoord(id.x  , id.y  , id.z  ) +Y;       //Y
        case 9: return 4*indexFromCoord(id.x+1, id.y  , id.z  ) +Y;     //+X Y
        case 10: return 4*indexFromCoord(id.x+1, id.y  , id.z+1) +Y;//+X+Z Y
        case 11: return 4*indexFromCoord(id.x  , id.y  , id.z+1) +Y;  //+Z Y
        default: return -1;
    }
}


Edge createEdge(float4 cubeCorners[8], int3 id, int index)
{
    Edge e;
    e.id = calculateEdgeIndex(id, index);
    int2 ep = cornerIndexFromEdge[index];
    e.p = interpolateVerts(cubeCorners[ep.x], cubeCorners[ep.y]);
    // e.pn = 0;
    return e;
}

void generateEdge(float4 cubeCorners[8], int3 id, int edgeRef, int index)
{
    if ((edgeRef & edgeFlags[index]) != 0)
    {
        Edge edge = createEdge(cubeCorners, id, index);
        uint count, stride;
        edges.GetDimensions(count, stride);
        edges.Append(edge);
    }
}

[numthreads(numThreads,numThreads,numThreads)]
void March (int3 id : SV_DispatchThreadID)
{
    int extent = numPointsPerAxis - 1;
    
    // Stop one point before the end because voxel includes neighbouring points
    if (id.x >= extent || id.y >= extent || id.z >= extent) {
        return;
    }

    // 8 corners of the current cube
    float4 cubeCorners[8] = {
        points[indexFromCoord(id.x, id.y, id.z)],
        points[indexFromCoord(id.x + 1, id.y, id.z)],
        points[indexFromCoord(id.x + 1, id.y, id.z + 1)],
        points[indexFromCoord(id.x, id.y, id.z + 1)],
        points[indexFromCoord(id.x, id.y + 1, id.z)],
        points[indexFromCoord(id.x + 1, id.y + 1, id.z)],
        points[indexFromCoord(id.x + 1, id.y + 1, id.z + 1)],
        points[indexFromCoord(id.x, id.y + 1, id.z + 1)]
    };

    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    // The value is used to look up the edge table, which indicates which edges of the cube are cut by the isosurface.
    int cubeIndex =
        ((int)saturate(sign(isoLevel - cubeCorners[0].w)) << 0)
        | ((int)saturate(sign(isoLevel - cubeCorners[1].w)) << 1)
        | ((int)saturate(sign(isoLevel - cubeCorners[2].w)) << 2)
        | ((int)saturate(sign(isoLevel - cubeCorners[3].w)) << 3)
        | ((int)saturate(sign(isoLevel - cubeCorners[4].w)) << 4)
        | ((int)saturate(sign(isoLevel - cubeCorners[5].w)) << 5)
        | ((int)saturate(sign(isoLevel - cubeCorners[6].w)) << 6)
        | ((int)saturate(sign(isoLevel - cubeCorners[7].w)) << 7);


    //Calculate 3 edges
    int edgeRef = edgeTable[cubeIndex];
    bool ex = id.x == extent-1;
    bool ey = id.y == extent-1;
    bool ez = id.z == extent-1;
    generateEdge(cubeCorners, id, edgeRef, 0);
    if (ex) generateEdge(cubeCorners, id, edgeRef, 1);
    if (ez) generateEdge(cubeCorners, id, edgeRef, 2);
    generateEdge(cubeCorners, id, edgeRef, 3);
    if (ey) generateEdge(cubeCorners, id, edgeRef, 4);
    if (ex && ey) generateEdge(cubeCorners, id, edgeRef, 5);
    if (ey && ez) generateEdge(cubeCorners, id, edgeRef, 6);
    if (ey) generateEdge(cubeCorners, id, edgeRef, 7);
    generateEdge(cubeCorners, id, edgeRef, 8);
    if (ex) generateEdge(cubeCorners, id, edgeRef, 9);
    if (ex && ez) generateEdge(cubeCorners, id, edgeRef, 10);
    if (ez) generateEdge(cubeCorners, id, edgeRef, 11);
    
    
    
    // Create triangles for current cube configuration
    for (int i = 0; triangulation[cubeIndex][i] != -1; i +=3) {
        // Get indices of corner points A and B for each of the three edges
        // of the cube that need to be joined to form the triangle.
        int e0 = triangulation[cubeIndex][i];
        int k0 = calculateEdgeIndex(id, e0);
        
        int e1 = triangulation[cubeIndex][i+1];
        int k1 = calculateEdgeIndex(id, e1);
        
        int e2 = triangulation[cubeIndex][i+2];
        int k2 = calculateEdgeIndex(id, e2);
        
        Triangle tri;
        tri.vertexA = k0;
        tri.vertexB = k1;
        tri.vertexC = k2;
                
        triangles.Append(tri);
    }

}
