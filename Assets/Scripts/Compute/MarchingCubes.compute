#pragma kernel March
// #include "./Includes/HashTable.compute"
#include "./Includes/MarchTables.compute"

static const int numThreads = 8;

struct Triangle {
    int vertexC;
    int vertexB;
    int vertexA;
};

struct Edge
{
    int id;
    //The interpolated point
    float3 p;
};

RWStructuredBuffer<float3> verts;
AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float> points;

int numPointsPerAxis;
float isoLevel;
float3 centre;
float boundsSize;
float spacing;

float3 interpolateVerts(float4 v1, float4 v2) {
    float t = (isoLevel - v1.w) / (v2.w - v1.w);
    return v1.xyz + t * (v2.xyz-v1.xyz);
}

int indexFromId(int3 id)
{
    return id.z * numPointsPerAxis * numPointsPerAxis + id.y * numPointsPerAxis + id.x;
}

// int indexFromCoord(int x, int y, int z) {
//     return z * numPointsPerAxis * numPointsPerAxis + y * numPointsPerAxis + x;
// }

int indexFromCoord(int3 id)
{
    return id.z * numPointsPerAxis * numPointsPerAxis + id.y * numPointsPerAxis + id.x;
}

float3 calculateNormal(Triangle tri) {
    //Set Vector U to (Triangle.p2 minus Triangle.p1)
    float3 u = tri.vertexB - tri.vertexA;
    //Set Vector V to (Triangle.p3 minus Triangle.p1)
    float3 v = tri.vertexC - tri.vertexA;
    
    //Set Normal.x to (multiply U.y by V.z) minus (multiply U.z by V.y)
    //Set Normal.y to (multiply U.z by V.x) minus (multiply U.x by V.z)
    //Set Normal.z to (multiply U.x by V.y) minus (multiply U.y by V.x)
    float3 normal = {
        (u.y * v.z) - (u.z * v.y),
        (u.z * v.x) - (u.x * v.z),
        (u.x * v.y) - (u.y * v.x)
    };
    //Returning Normal
    return normal;
}

int calculateEdgeIndex(int3 id, int edge)
{
    const int X = 0;
    const int Y = 1;
    const int Z = 2;
    switch (edge)
    {
        case 0 : return 3*indexFromCoord(id+int3(0,0,0)) +X; //     X
        case 1 : return 3*indexFromCoord(id+int3(1,0,0)) +Z; //.X   Z
        case 2 : return 3*indexFromCoord(id+int3(0,0,1)) +X; //.Z   X
        case 3 : return 3*indexFromCoord(id+int3(0,0,0)) +Z; //     Z
        case 4 : return 3*indexFromCoord(id+int3(0,1,0)) +X; //.Y   X
        case 5 : return 3*indexFromCoord(id+int3(1,1,0)) +Z; //.X.Y Z
        case 6 : return 3*indexFromCoord(id+int3(0,1,1)) +X; //.Y.Z X
        case 7 : return 3*indexFromCoord(id+int3(0,1,0)) +Z; //.Y   Z
        case 8 : return 3*indexFromCoord(id+int3(0,0,0)) +Y; //     Y
        case 9 : return 3*indexFromCoord(id+int3(1,0,0)) +Y; //.X   Y
        case 10: return 3*indexFromCoord(id+int3(1,0,1)) +Y; //.X.Z Y
        case 11: return 3*indexFromCoord(id+int3(0,0,1)) +Y; //.Z   Y
        default: return -1;
    }
}

void generateEdge(float4 cubeCorners[8], int3 id, int edgeRef, int index)
{
    if (edgeRef & edgeFlags[index])
    {
        int2 ep = cornerIndexFromEdge[index];
        verts[calculateEdgeIndex(id, index)] = interpolateVerts(cubeCorners[ep.x], cubeCorners[ep.y]);
    }
}

float4 cornerFromId(int3 id)
{
    return float4((centre + id * spacing - boundsSize*0.5).xyz, points[indexFromCoord(id)]);
}

[numthreads(numThreads,numThreads,numThreads)]
void March (int3 id : SV_DispatchThreadID)
{
    int extent = numPointsPerAxis - 1;
    
    // Stop one point before the end because voxel includes neighbouring points
    if (id.x >= extent || id.y >= extent || id.z >= extent) {
        return;
    }

    // 8 corners of the current cube
    float4 cubeCorners[8] = {
        cornerFromId(id + int3(0,0,0)),
        cornerFromId(id + int3(1,0,0)),
        cornerFromId(id + int3(1,0,1)),
        cornerFromId(id + int3(0,0,1)),
        cornerFromId(id + int3(0,1,0)),
        cornerFromId(id + int3(1,1,0)),
        cornerFromId(id + int3(1,1,1)),
        cornerFromId(id + int3(0,1,1)),
    };

    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    // The value is used to look up the edge table, which indicates which edges of the cube are cut by the isosurface.
    //*Use a branchless union of all the point comparisons
    int cubeIndex =
        ((int)saturate(sign(isoLevel - cubeCorners[0].w)) << 0)
        | ((int)saturate(sign(isoLevel - cubeCorners[1].w)) << 1)
        | ((int)saturate(sign(isoLevel - cubeCorners[2].w)) << 2)
        | ((int)saturate(sign(isoLevel - cubeCorners[3].w)) << 3)
        | ((int)saturate(sign(isoLevel - cubeCorners[4].w)) << 4)
        | ((int)saturate(sign(isoLevel - cubeCorners[5].w)) << 5)
        | ((int)saturate(sign(isoLevel - cubeCorners[6].w)) << 6)
        | ((int)saturate(sign(isoLevel - cubeCorners[7].w)) << 7);


    int edgeRef = edgeTable[cubeIndex];
    bool ex = id.x == extent-1;
    bool ey = id.y == extent-1;
    bool ez = id.z == extent-1;
    
    //Calculate 3 edge midpoints
    generateEdge(cubeCorners, id, edgeRef, 0);
    generateEdge(cubeCorners, id, edgeRef, 3);
    generateEdge(cubeCorners, id, edgeRef, 8);
    //If at an extent, calculate for the last plane of points
    if (ex) generateEdge(cubeCorners, id, edgeRef, 1);
    if (ex) generateEdge(cubeCorners, id, edgeRef, 9);
    if (ex && ey) generateEdge(cubeCorners, id, edgeRef, 5);
    if (ex && ez) generateEdge(cubeCorners, id, edgeRef, 10);
    if (ey) generateEdge(cubeCorners, id, edgeRef, 4);
    if (ey) generateEdge(cubeCorners, id, edgeRef, 7);
    if (ey && ez) generateEdge(cubeCorners, id, edgeRef, 6);
    if (ez) generateEdge(cubeCorners, id, edgeRef, 2);
    if (ez) generateEdge(cubeCorners, id, edgeRef, 11);
        
    // Create triangles for current cube configuration
    for (int i = 0; triangulation[cubeIndex][i] != -1; i +=3) {
        // Get indices of corner points A and B for each of the three edges
        // of the cube that need to be joined to form the triangle.
        int e0 = triangulation[cubeIndex][i];
        int k0 = calculateEdgeIndex(id, e0);
        
        int e1 = triangulation[cubeIndex][i+1];
        int k1 = calculateEdgeIndex(id, e1);
        
        int e2 = triangulation[cubeIndex][i+2];
        int k2 = calculateEdgeIndex(id, e2);
        
        Triangle tri;
        tri.vertexA = k0;
        tri.vertexB = k1;
        tri.vertexC = k2;
                
        triangles.Append(tri);
    }

}

